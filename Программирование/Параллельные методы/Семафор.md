#Параллелизм #Паттерн_синхронизации

**Семафоры** являются еще одним **инструментом**, который предлагает нам платформа .NET для управления синхронизацией. Технически, **Семафор** представляет собой счётчик, над которым можно выполнять две операции: инкремент и декремент. **Семафоры** позволяют ограничить количество потоков, которые имеют доступ к определенным ресурсам. В .NET семафоры представлены классом Semaphore. 

- # Объекты, которые используются для управления доступом к общим ресурсам из нескольких потоков. 

Для создания семафора применяется один из конструкторов класса **Semaphore**:

- **Semaphore (int initialCount, int maximumCount):** параметр `initialCount` задает начальное количество потоков, а `maximumCount` - максимальное количество потоков, которые имеют доступ к общим ресурсам
- **Semaphore (int initialCount, int maximumCount, string? name)**: в дополнение задает имя семафора
- **Semaphore (int initialCount, int maximumCount, string? name, out bool createdNew)**: последний параметр - `createdNew` при значении `true` указывает, что новый семафор был успешно создан. Если этот параметр равен `false`, то семафор с указанным именем уже существует

Для работы с потоками класс `Semaphore` имеет два основных метода:

- **WaitOne():** ожидает получения свободного места в семафоре
- **Release()**: освобождает место в семафоре

- ## Виды семафоров

Семафоры могут быть **двоичными** и **вычислительными**. 
- **Вычислительные** семафоры могут принимать целочисленные неотрицательные значения и используются для работы с ресурсами, количество которых ограничено, либо участвуют в синхронизации параллельно исполняемых задач. 
- **Двоичные** семафоры могут принимать только значения `0` и `1` и используются для взаимного исключения одновременного нахождения двух или более процессов в своих критических секциях.

Семафоры [[Мьютекс]] являются упрощённой реализацией семафоров, аналогичной двоичным семафорам с тем отличием, что мьютексы должны отпускаться тем же процессом или потоком, который осуществляет их захват, однако в зависимости от типа и реализации попытка освобождения другим потоком может как освободить мьютекс, так и вернуть ошибку.

- ## Пример

 - #### Например, задача: есть некоторое число читателей, которые приходят в библиотеку три раза в день и что-то там читают. И пусть у нас будет ограничение, что единовременно в библиотеке не может находиться больше трех читателей. Данную задачу очень легко решить с помощью семафоров:

`// запускаем пять потоков`
`for` `(``int` `i = 1; i < 6; i++)`
`{`
    `Reader reader =` `new` `Reader(i);`
`}`

`class` `Reader`
`{`
    `// создаем семафор`
    `static` `Semaphore sem =` `new` `Semaphore(3, 3);`
    `Thread myThread;`
    `int` `count = 3;``// счетчик чтения`
    
    `public` `Reader(``int` `i)`
    `{`
        `myThread =` `new` `Thread(Read);`
        `myThread.Name = $``"Читатель {i}"``;`
        `myThread.Start();`
    `}`

    `public` `void` `Read()`
    `{`
        `while` `(count > 0)`
        `{`
            `sem.WaitOne();`  `// ожидаем, когда освободиться место`
            `Console.WriteLine($``"{Thread.CurrentThread.Name} входит в библиотеку"``);`
            `Console.WriteLine($``"{Thread.CurrentThread.Name} читает"``);`
            `Thread.Sleep(1000);`
            `Console.WriteLine($``"{Thread.CurrentThread.Name} покидает библиотеку"``);`

            `sem.Release();`  `// освобождаем место`
            `count--;`
            `Thread.Sleep(1000);`
        `}`
    `}`
`}`

1. Когда вы создаете семафор, вы можете инициализировать его значение любым целым числом, но после этого вам разрешено выполнять только операции инкремента (увеличения на единицу) и декремента (уменьшения на единицу). Вы не можете прочитать текущее значение семафора.
   
2. Когда поток уменьшает значение семафора, если результат отрицательный,  
поток блокируется и не может продолжать работу до тех пор, пока другой поток не увеличит значение семафора.
  
3. Когда поток увеличивает семафор, если есть другие ожидающие потоки, один из ожидающих потоков разблокируется.

