
Итак, следите за именами в своих программах и изменяйте их, если найдете более удачные варианты. Этим вы упростите жизнь каждому, кто читает ваш код (в том числе и себе самому). 

- # Имя переменной, функции или класса должно отвечать на все главные вопросы. 

Оно должно сообщить
- почему эта переменная (и т. д.) существует, 
- что она делает 
- как используется.

Если имя требует дополнительных комментариев, значит, оно не передает намерений программиста.

`int d; // Прошедшее время`

Имя d не передает ровным счетом ничего. Оно не ассоциируется ни с временными интервалами, ни с днями. Его следует заменить другим именем, которое указывает, что именно измеряется и в каких единицах: 

`int elapsedTimeInDays; 
`int daysSinceCreation; 
`int daysSinceModification; 
`int fileAgeInDays;`

- ### Имя переменной / поля должно быть понятным, прямо отражать суть своего содержания и намерение.

## **Пример рефакторинга: именования**

`public List getThem() { 
	`List list1 = new ArrayList(); 
	`for (int[] x : theList) 
		`if (x[0] == 4) 
			`list1.add(x); 
`return list1; }`

Проблема: код не очевиден, из наименований нельзя понять контекст.

Возникающие вопросы:

1) Чем важен 0-й элемент, почему именно он
2) Что за магическое число 4
3) Какой формат входных данных
4) По имени возвращаемого массива не ясно его дальнейшее использование
5) Именование метода не дает ясности - получить их - кого, что?

Переименуем именования, допустив, то речь идет об игре "Сапер" и мы хотим получить все ячейки, где установлены флажки.

`public List<int[]> getFlaggedCells() {
 `List<int[]> flaggedCells = new ArrayList<int[]>();
 `for (int[] cell : gameBoard)
	 `if (cell[STATUS_VALUE] == FLAGGED)
	 `flaggedCells.add(cell);
 `return flaggedCells;
``}

Следующим шагом может быть выделение абстракции **Cell** с методом **isFlagged**, явно показывающем намерение - дать информацию о наличии или отсутствии флажка

`public List getFlaggedCells() { 
	`List flaggedCells = new ArrayList(); 
	`for (Cell cell : gameBoard) 
		`if (cell.isFlagged()) 
			`flaggedCells.add(cell); 
`return flaggedCells; 
``}

## **Избегать дезинформации**

- Не использовать имена, которые могут ввести в заблуждение путем вызова ложных ассоциаций, отличных от предполагаемой. Лучше прямо передавать заложенный смысл имени. Не нужно использовать  аббревиатуры и сокращения без реальной необходимости передать общепринятые и понятные из примеры, например **URL, IP**.

- Не стоит использовать в именах названия структур данных, если если эта структура данных не используется в этой переменной / поле: Не обозначайте группу учетных записей именем **accountList**, если только она действительно не хранится в списке (**List**). Слово «список» имеет для программиста вполне конкретный смысл. Если записи хранятся не в **List**, а в другом контейнере,  это может привести к ложным выводам1 . В этом примере лучше подойдет имя **accountGroup, bunchOfAccounts** и даже просто **accounts**.

- Остерегаться слишком похожих названий, чтобы избежать путаницы, которую визуально потом сложно заметить. Сколько времени понадобится, чтобы заметить незначительное различие в **XYZControllerForEfficientHandlingOfStrings** в одном модуле и **XYZControllerForEfficientStorageOfStrings** где-то в другом месте? Эти имена выглядят устрашающе похожими.

- Имена из одного символа могут дезинформировать, особенно строчные O и L, (o, l), которые очень схожи с 0 и 1. Использование при описании формул ситуативно.

- ### Имя должно давать точную информацию о своем предназначении. Не стоит использовать дезинформирующие имена, которые не отражают сути или вызывают неправильные ассоциации. Это же касается слишком похожих имен.

## **Используйте осмысленные различия**

«Числовые ряды» вида (a1, a2, .. aN) являются противоположностью сознательного присваивания имен. Такие имена не дезинформируют — они просто не несут информации и не дают представления о намерениях автора.

`public static void copyChars(char a1[], char a2[]) {
`` for (int i = 0; i < a1.length; i++) {
 `a2[i] = a1[i];
 ``}
``}

Решение: переименование в **source** и **destination**

Неинформативные слова также применяются для создания бессодержательных различий. Допустим, у вас имеется класс **Product**. Создав другой класс с именем **ProductInfo** или **ProductData**, вы создаете разные имена, которые по сути обозначают одно и то же.

При отсутствии жестких именных схем имя **moneyAmount** не отличается от **money**, **customerInfo** не отличается от **customer**, **accountData** не отличается от **account**, а **theMessage** — от **message**. Записывайте различающиеся имена так, чтобы читатель кода понимал, какой смысл заложен в этих различиях.

- ### Различия в именах должны быть понятными, с определенными и четкими границами. Не стоит добавлять к уже существующему имени абстрактные и синонимичные части, надеясь на понятное различие сути имен.

## **Использовать удобопроизносимые имена**

В одной известной мне компании используется переменная genymdhms (дата генерирования, год, месяц, день, час, минуты и секунды), поэтому программисты упоминали в своих разговорах «ген-уай-эм-ди-эйч-эм-эс»

Сравним:

`class DtaRcrd102 { 
`private Date genymdhms; 
`private Date modymdhms; 
`private final String pszqint = "102"; 
``}; 
и 
`class Customer {
`` private Date generationTimestamp;
`` private Date modificationTimestamp;;
`` private final String recordId = "102";
``};

- ### Использовать имена, который удобно произносить, передавая понятный смысл, независимо от сложности имени

## **Выбирать имена, удобные для поиска**

Хорошие наименования позволяют легко отыскивать поля, переменные, методы и т.д. благодаря тому, что оно понятно и уникально. Если бы это была одна буква - то ее вхождений помимо имени переменной будет в разы больше.

Имя из одной буквы допустимо **только** в коротких методах.

Пример: 

`for (int j=0; j<34; j++) {
 `s += (t[j]*4)/5;
``}

и 

`for (int j=0; j < NUMBER_OF_TASKS; j++) {	
`` sum += realTaskWeeks;
``} 

Сознательное присваивание имен увеличивает длину функции, но подумайте, насколько проще найти **WORK_DAYS_PER_WEEK**, чем искать все вхождения цифры **5** и фильтровать список до позиций с нужным смыслом.

- ### Здесь можно вывести правило: длина имени должно соответствовать размеру области видимости. Переменная с неясным именем из одной-двух букв легко потеряется в методе огромного размера.

## **Избегайте схем кодирования имен**

- ### Сложно поддерживать какую-то схему кодирования имен, особенно, когда нужно каждому новому сотруднику ее объяснять. Лучше придерживаться изначально понятных именований.

## **Префиксы членов классов**

- ### Больше нет необходимости использовать особые префиксы m_ и подобные для выделения имен членов класса.

##  Мысленные преобразования

- ### Правило смежно с проблемой ложных ассоциаций. Имена, в силу не прямоты и неясности, не должны вызывать у читателя мысленные преобразования к тому, а что же это значит на самом деле.

## Имена классов

Имена классов - это существительные, описывающие сущность, и их комбинации: **Customer**, **Product**, **UnitFactory**, **User** и т.п. Не стоит использовать в именах **Data**, **Info**, **Manager**, т.к. это размывает границы ответственности класса и часто не несет смысловой нагрузки.

- ### Имена классов и объектов должны представлять собой существительные и их комбинации. Оно не должно быть глаголом.

## Имена методов

Имена методов - это **глаголы** и **глаголы + существительные**, то есть - **действие** и **действие с чем/над чем**.

**CalculateAngels**, **LoadListToDataBase**, **Expand**, **Interact**, **Shoot**

## Вариации написания комбинаций

![[Pasted image 20230616122107.png]]

## Выберите одно слово для каждой концепции

Выберите одно слово для представления одной абстрактной концепции и придерживайтесь его. Например, существование в разных классах эквивалентных методов с именами **fetch**, **retrieve** и **get** неизбежно создаст путаницу.

Та же ситуация с **Controller**, **Driver**, **Manager**

- ### Использовать единый согласованный лексикон и наименования определенных типов, классов.

