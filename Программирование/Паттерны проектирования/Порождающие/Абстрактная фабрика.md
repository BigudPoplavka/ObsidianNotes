
Порождающий шаблон проектирования, предоставляет интерфейс для создания **семейств  взаимозависимых объектов**, **НЕСКОЛЬКО СЕМЕЙСТВ**, не специфицируя их конкретных классов. Шаблон реализуется созданием **абстрактного** класса **Factory**, который представляет собой интерфейс для создания компонентов системы. 

## Задача

Есть несколько групп классов, каждую из которых можно объединить под общим интерфейсом (или абстрактным классом). Необходимо создавать эти объекты из каждого семейства по принципу фабрики, но нужна логическая согласованность этих объектов.

**Например**:
- есть ресурсы: *энергия* и *деньги*
- есть разные типы наград: *ежедневная* и *квестовая*
- нужно как-то сделать поддержку уникальности разных UI стилей для разных типов квестов. Нужно, чтобы было можно добавлять новые стили и ресурсы.

## Особенности

- абстрактная фабрика предоставляет общий тип для создания **семейств объектов**, т.е. **нужную клиенту фабрику** 
- В ОТЛИЧИЕ ОТ ФАБРИЧНОГО МЕТОДА передает фабрику **В ПОЛЕ ЧЕРЕЗ КОНСТРУКТОР КЛИЕНТА - ЧЕРЕЗ КОМПОЗИЦИЮ, А НЕ НАСЛЕДОВАНИЕ,** как у фабричного метода
- имеет интерфейс (абстрактные методы создания) для нескольких типов сразу, **НЕСКОЛЬКО СЕМЕЙСТВ**, в то время как [[Фабричный метод]] имеет только один интерфейс 
- при добавлении нового семейства (интерфейса) в фабрику, меняются все фабрики наследники, т.к. нужно переопределить новый фабричный метод

## Решение

В приведенном примере сначала выделим общие типы для семейств классов - это 
- `MoneyView`
- `EnergyView`

Опишем их конкретные реализации для разных типов наград
- `QuestMoneyView: MoneyView`
- `QuestEnergyView: EnergyView`

Создадим абстрактную фабрику с методами создания базовых типов семейств классов
- `AbstractViewFactory`

Создадим конкретные фабрики для каждого типа наград
- `DailyViewFabric : AbstractViewFactory`
- `QuestViewFabric : AbstractViewFactory`
## **UML-схема**

![[Pasted image 20230819141846.png]]

## Шаги реализации

1. Определить базовые типы/интерфейсы семейств классов
2. Создаем интерфейс или абстрактный класс фабрики
3.  Создаем абстрактные фабричные методы для семейств классов, возвращающих их базовые типы
4. Создаем конкретные фабрики, наследуясь от абстрактной и реализуя ее фабричные методы.
