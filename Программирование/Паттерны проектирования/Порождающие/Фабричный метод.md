Шаблон описывает способ инкапсулирования группы индивидуальных фабрик, объединённых некой темой, **ОДНИМ СЕМЕЙСТВОМ**, без указания для них конкретных классов.

## Задача

Клиентский код требует некие объекты - бизнес-сущности для бизнес-процесса.
Объекты схожи по своему типу (**общий интерфейс**), как сущности, но все же отличаются внутренней логикой. Необходимо реализовать логику создания нужного в каждый момент объекта.

## Особенности

- Код не знает какой именно тип объекта придет, это определяется в runtime
- Бизнес-объекты могут изменяться и добавляться новые. При этом клиентский код не затрагивается и останется расширяемым - Open-Close [[SOLID Принципы]]
- Повторное использование кода
- **В ОТЛИЧИЕ ОТ АБСТРАКТНОЙ ФАБРИКИ** использует **наследование** конкретных фабрик, расширяет класс, тем, что добавляет туда **переопределенный метод создания объекта**
- В ОТЛИЧИЕ ОТ АБСТРАКТНОЙ ФАБРИКИ ИМЕЕТ ОДИН ИНТЕРФЕЙС (один абстрактный метод, только одно семейство) 

## Решение

Для каждого требуемого подтипа выделяются фабрики под конкретные подтипы.
Логика создания может совпадать для подтипов, поэтому во избежание повторяющегося кода выделяется одна абстрактная **фабрика фабрик**, которая и содержит в себе тот самый **фабричный метод**. 

Эта абстрактная фабрика есть родительский абстрактный класс для наследников - конкретных фабрик подтипов.  

Конкретные фабрики **переопределяют абстрактный ФАБРИЧНЫЙ метод абстрактной фабрики родителя.**

![[Pasted image 20221223225452.png]]

## UML-схема

- Интерфейс целевой бизнес-сущности
- Абстрактная фабрика - класс родитель для фабрик подтипов
- Фабрики подтипов бизнес-сущности
- Порождаемые классы подтипов (реализаторы интерфейса)

![[Pasted image 20221223230306.png]]

## Шаги реализации

1. Сначала определим **интерфейс исходящего объекта** и его реализаторов (**конкретные типы**)
2. Создать **фабричный метод**, возвращающий **базовый тип** продукта
3. Создать **подклассы фабрик**, возвращающих конкретные типы продуктов