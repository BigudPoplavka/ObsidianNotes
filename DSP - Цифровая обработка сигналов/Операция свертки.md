#цифровая_обработка_сигналов 

[[Свертка]]

В системах **LTI свертка** используется для описания взаимосвязи между входным сигналом, импульсной характеристикой и выходным сигналом.

**Импульсный ответ** - **_является выходным сигналом системы, когда входной сигнал является импольсной единицей._**

![[Pasted image 20231111121317.png]]

**Импульсная характеристика** является **уникальной характеристикой любой системы** **LTIи** описывается следующим образом:

![[Pasted image 20231111121357.png]]

Это уравнение называется **суммой свертки** . Свертка обозначается символом `«*» : y[n]=x[n]*h[n].` Вот как мы получаем выходной сигнал.

Уравнение отражает идею так называемого _входного алгоритма_ для вычисления свертки. Он анализирует, как _каждая_ выборка во входном сигнале влияет на _множество_ выборок в выходном сигнале. Алгоритм на стороне ввода очень полезен для концептуального понимания свертки. Однако, с точки зрения программирования, наиболее простым методом было бы циклическое прохождение отсчетов _выходного_ сигнала. Эта идея лежит в основе _алгоритма на стороне вывода,_ согласно которому _каждый_ отсчет выходного сигнала является некоторой комбинацией _множества_ значений входного сигнала и импульсной характеристики:
![[Pasted image 20231111130313.png]]

На практике мы имеем дело с конечными сигналами, поэтому только несколько отсчетов, используемых в расчетах, отличны от нуля. Предполагая, что входной сигнал содержит _N_ отсчетов, а импульсная характеристика состоит из _M_ отсчетов, предыдущую формулу можно переписать как:

![[Pasted image 20231111130143.png]]

Компонент _h[k]_ часто называют _сверточной машиной._ Он скользит по образцам входного сигнала. Результирующий сигнал будет содержать _N+M–1_ отсчетов. Предполагается, что входной сигнал содержит _N_ отсчетов, а импульсная характеристика состоит из _M_ отсчетов.

- ##### Пример:
	**Сверните сигнал** `x = {1,5,3,2,6}` **с сигналом** `h = {2,3,1}.` **Постройте результат.**
	Во время расчета первой выходной выборки мы заметим, что алгоритм выходной стороны работает с несуществующими входными выборками `x[-2] и x[-1]`: 
	`у[0] = х[-2]*h[0] + х[-1]*h[1] + х[0]*h[2]`
	
	![[Pasted image 20231111185303.png]]
	
	Это удобнее представить, как цикл по **i** и вложенный цикл по **j**, где везде, кроме граничных случаев, сопоставление шло бы вот такими шагами: **/ | \\**, т.к. для каждого слагаемого суммы индекс **i** **уменьшается**, а **j увеличивается** 
	![[Pasted image 20231111191922.png]]
	![[Pasted image 20231111191941.png]]
	![[Pasted image 20231111192001.png]]
	![[Pasted image 20231111192951.png]]
	![[Pasted image 20231111193131.png]]
	![[Pasted image 20231111193427.png]]




