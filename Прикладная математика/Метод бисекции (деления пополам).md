#Алгоритмы #Итерационные_методы 

![[Pasted image 20230924233833.png]]

- ## Алгоритм

**Выберем отрезок** `[a, b]`, в котором находится корень, некое `x*, f(x*) = 0`

1) **Задаем начальное приближение** - `x0 = (a + b) / 2`
2) **Находим ф-цию в этой точке** `f(x0)`
3) **Проверяем:** если знак функции на первом отрезке `[a, x0]`, если знак `f(a) != f(x0)`, то решение находится в пределах этого отрезка, а второй отрезок уже не рассматриваем, т.к. если знаки `f(x0)` равен знаку  `f(b)`, то значит пересечения `OX` не было и там решения **нет**

4) Повторяем в цикле для нового отрезка.

Например, когда уточнение решения идет влево к `a`, то имеется циклическое изменение отрезка, когда правая граница `Xi` смещается ближе левее к `a` на каждом шаге

`x1 = (a + x0) / 2`, вычисляем `f(x1)` и получаем `[a, x1]`
`x2 = (a + x1) / 2`, вычисляем `f(x2)` и получаем `[a, x2]`
...
`xi = (a + x[i-1]]) / 2`, вычисляем `f(xi)` и получаем `[a, xi]`


5) Оканчиваем цикл, когда значение удовлетворяет заданной точности `E`: `(a, x*) < E > 0`

За `x*` принимаем среднее значение последнего интервала 

- ## Преимущества

1. Достаточно прост и устойчив
2. Из особенностей функции требует только **непрерывность**

- ## Недостатки

1. Относительно медлителен