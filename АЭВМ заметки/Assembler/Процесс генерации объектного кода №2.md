![[Pasted image 20220406181812.png]]
![[Pasted image 20220406181830.png]]
![[Pasted image 20220406181856.png]]
![[Pasted image 20220406181926.png]]
![[Pasted image 20220406181952.png]]
На рис. 8.2(а) приведено дерево грамматического разбора предложения. Основная работа при разборе предложения состоит в анализе нетерминального символа <exp> в правой части оператора присваивания. В процессе грамматического разбора идентификатор SUMSQ распознается сначала как <factor>, потом как <term>. Далее распознается целое число 100 как <factor>. 

Затем фрагмент SUMSQ DIV 100 распознается как <term> и т.д. Порядок распознавания фрагментов этого предложения совпадает с порядком, в котором должны выполняться соответствующие вычисления. Сначала вычисляются подвыражения SUMSQ DIV 100 и MEAN * MEAN, а затем второй результат вычитается из первого.  

Как только очередной фрагмент предложения распознан, вызывается соответствующая программа генерации кода.

Пример. Сгенерировать код, соответствующий правилу <term>1 ::= <term>2*<factor>

Индексы здесь использованы для различения двух вхождений нетерминального символа <term>. Данные программы генерации кода выполняют все арифметические операции с использованием регистра А, и следует заведомо сгенерировать в объектном коде операцию MUL.  

Результат этого умножения <term>1 после операции MUL сохранится в регистре А. Если либо <term>2, либо <factor> уже находятся в регистре А (после выполнения предыдущих вычислений), генерация инструкции MUL – это все, что требуется. Иначе нужно сгенерировать также инструкцию LDA, предшествующую инструкции MUL. Также надо предварительно сохранить значение регистра А, если оно понадобится в будущем.

Очевидно, необходимо отслеживать значение, помещенное в регистр А, после каждого фрагмента генерируемого объектного кода. Это можно осуществить за счет расширения понятия спецификатора лексемы на нетерминальные узлы дерева грамматического разбора. В рассмотренном примере спецификатору узла S(<term>1) будет присвоено значение rA, указывающее на то, что результат вычислений содержится в регистре А.  

Переменная REGA используется для указания на самый высокий уровень узла дерева грамматического разбора, значение которого помещено в регистр А в сгенерированном до данного момента объектном коде (т.е. указатель на узел, спецификатор которого равен rA). В каждый момент процесса генерации объектного кода существует ровно один такой узел.  

Если же в регистре А нет значения, соответствующего некоторому узлу, то спецификатор этого узла аналогичен спецификатору лексемы: это либо указатель на переменную (в таблице символов), содержащую соответствующее значение, либо указатель на целую константу.

Рассмотрим программу генерации кода на рис. 8.2 (б), соответствующую правилу <term>1 ::= <term>2*<factor>  

Если спецификатор узла какого-либо из операндов равен rA, то соответствующее значение уже содержится в регистре А, и программа генерирует только одну инструкцию MUL. Адрес операнда для инструкции MUL содержится в спецификаторе узла другого операнда (значение которого не находится на регистре А). Иначе вызывается процедура GETA, изображенная на рис. 8.2 (в). 

Она генерирует инструкцию LDA для загрузки значения, связанного со значением <term>2, в регистр А. Дополнительно перед инструкцией LDA процедура генерирует инструкцию STA для сохранения текущего значения регистра А, если только REGA не нуль (равенство REGA нулю означает, что это значение больше не понадобится). Это значение запоминается в некоторой рабочей переменной. Рабочие переменные образуются в процессе генерации объектного кода (с именами T1, T2, …) по мере необходимости.  

Для рабочих переменных будет отведено место в конце объектной программы. На узел дерева грамматического разбора, связанный со значением, содержащимся в регистре А, указывает переменная REGA.  

Спецификатор этого узла модифицируется, чтобы указывать на рабочую переменную, используемую для хранения этого значения.  

После того как все необходимые инструкции сгенерированы, программа генерации кода устанавливает спецификатор S (<term>1) и переменную REGA таким образом, чтобы было видно, что значение, соответствующее <term>1, находится в настоящее время в регистре А. На этом процедура генерации кода для операции * завершается.  

Программа генерации кода, соответствующая операции +, почти совпадает с рассмотренной программой для операции *. Программы для DIV и «–» также аналогичны, за исключением того, что для этих операций необходимо, чтобы на регистре А был установлен именно первый операнд.  

Программа генерации кода для операции присваивания <assign> состоит в загрузке присваиваемой величины на регистр A (с использованием GETA) и генерации инструкции STA. Переменная REGA потом обнуляется, так как код, соответствующий предложению присваивания, полностью сгенерирован и промежуточные результаты больше не нужны.  

Оставшиеся правила, показанные на рис. 8.2 (б), не требуют генерации каких-либо машинных инструкций, поскольку они не соответствуют никаким вычислениям или перемещениям данных.

